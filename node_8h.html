<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libdht: /home/travis/build/naturalpolice/libdht/include/dht/node.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdht
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_e7d75a8427fafea27b500c59b0da00f9.html">dht</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">node.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>API for running a DHT node.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &quot;<a class="el" href="bencode_8h_source.html">bencode.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for node.h:</div>
<div class="dyncontent">
<div class="center"><img src="node_8h__incl.png" border="0" usemap="#_2home_2travis_2build_2naturalpolice_2libdht_2include_2dht_2node_8h" alt=""/></div>
<map name="_2home_2travis_2build_2naturalpolice_2libdht_2include_2dht_2node_8h" id="_2home_2travis_2build_2naturalpolice_2libdht_2include_2dht_2node_8h">
<area shape="rect" id="node4" href="bencode_8h.html" title="Provides routines for parsing and formating bencoded data. " alt="" coords="227,109,316,136"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="node_8h__dep__incl.png" border="0" usemap="#_2home_2travis_2build_2naturalpolice_2libdht_2include_2dht_2node_8hdep" alt=""/></div>
<map name="_2home_2travis_2build_2naturalpolice_2libdht_2include_2dht_2node_8hdep" id="_2home_2travis_2build_2naturalpolice_2libdht_2include_2dht_2node_8hdep">
<area shape="rect" id="node2" href="put_8h.html" title="Get or put mutable/immutable items. " alt="" coords="5,109,152,165"/>
</map>
</div>
</div>
<p><a href="node_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsearch__node.html">search_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search node.  <a href="structsearch__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structip__counter__entry.html">ip_counter_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">External IP counter entry.  <a href="structip__counter__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structip__counter.html">ip_counter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">External IP counter.  <a href="structip__counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdht__node.html">dht_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DHT node object.  <a href="structdht__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a736b2d62686f9713e08e11b25e8d02cd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a736b2d62686f9713e08e11b25e8d02cd">search_complete_t</a>) (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const struct <a class="el" href="structsearch__node.html">search_node</a> *nodes, void *opaque)</td></tr>
<tr class="memdesc:a736b2d62686f9713e08e11b25e8d02cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search complete callback.  <a href="#a736b2d62686f9713e08e11b25e8d02cd">More...</a><br /></td></tr>
<tr class="separator:a736b2d62686f9713e08e11b25e8d02cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b5e3db1421f18e2106a5dbe1a44207"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a73b5e3db1421f18e2106a5dbe1a44207">node_output_t</a>) (const unsigned char *data, size_t len, const struct sockaddr *dest, socklen_t addrlen, void *opaque)</td></tr>
<tr class="memdesc:a73b5e3db1421f18e2106a5dbe1a44207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node output callback.  <a href="#a73b5e3db1421f18e2106a5dbe1a44207">More...</a><br /></td></tr>
<tr class="separator:a73b5e3db1421f18e2106a5dbe1a44207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1683aa1d614d82219fa3712dab05857"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#ac1683aa1d614d82219fa3712dab05857">bootstrap_status_t</a>) (int ready, void *opaque)</td></tr>
<tr class="memdesc:ac1683aa1d614d82219fa3712dab05857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bootstrap status notification callback.  <a href="#ac1683aa1d614d82219fa3712dab05857">More...</a><br /></td></tr>
<tr class="separator:ac1683aa1d614d82219fa3712dab05857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75404d24c510013ce7d61dee6d25323b"><td class="memItemLeft" align="right" valign="top">typedef struct search *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a75404d24c510013ce7d61dee6d25323b">dht_search_t</a></td></tr>
<tr class="memdesc:a75404d24c510013ce7d61dee6d25323b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search handle.  <a href="#a75404d24c510013ce7d61dee6d25323b">More...</a><br /></td></tr>
<tr class="separator:a75404d24c510013ce7d61dee6d25323b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a37cacf032444dc865b3e4290fb445aec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37cacf032444dc865b3e4290fb445aec"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a37cacf032444dc865b3e4290fb445aec">dht_search_type</a> { <b>FIND_NODE</b>, 
<b>GET_PEERS</b>, 
<b>GET</b>
 }<tr class="memdesc:a37cacf032444dc865b3e4290fb445aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of DHT search. <br /></td></tr>
</td></tr>
<tr class="separator:a37cacf032444dc865b3e4290fb445aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a823c75f4036a068ef420ad4b50b73419"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a823c75f4036a068ef420ad4b50b73419">dht_node_init</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const unsigned char *id, <a class="el" href="node_8h.html#a73b5e3db1421f18e2106a5dbe1a44207">node_output_t</a> output, void *opaque)</td></tr>
<tr class="memdesc:a823c75f4036a068ef420ad4b50b73419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize DHT node.  <a href="#a823c75f4036a068ef420ad4b50b73419">More...</a><br /></td></tr>
<tr class="separator:a823c75f4036a068ef420ad4b50b73419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d271bbce0682f65e7b1a861a7d85df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a05d271bbce0682f65e7b1a861a7d85df">dht_node_start</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n)</td></tr>
<tr class="memdesc:a05d271bbce0682f65e7b1a861a7d85df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start DHT node.  <a href="#a05d271bbce0682f65e7b1a861a7d85df">More...</a><br /></td></tr>
<tr class="separator:a05d271bbce0682f65e7b1a861a7d85df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d88ecca1430b75b6a0d4e897effb823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a2d88ecca1430b75b6a0d4e897effb823">dht_node_input</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const unsigned char *data, size_t len, const struct sockaddr *src, socklen_t addrlen)</td></tr>
<tr class="memdesc:a2d88ecca1430b75b6a0d4e897effb823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a received UDP datagram.  <a href="#a2d88ecca1430b75b6a0d4e897effb823">More...</a><br /></td></tr>
<tr class="separator:a2d88ecca1430b75b6a0d4e897effb823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cadf472420de8aeace356755669cf65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a1cadf472420de8aeace356755669cf65">dht_node_ping</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, struct sockaddr *dest, socklen_t addrlen)</td></tr>
<tr class="memdesc:a1cadf472420de8aeace356755669cf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ping remote node.  <a href="#a1cadf472420de8aeace356755669cf65">More...</a><br /></td></tr>
<tr class="separator:a1cadf472420de8aeace356755669cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f03901aba6f1e4df97ae91486bf27f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a57f03901aba6f1e4df97ae91486bf27f">dht_node_timeout</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, struct timeval *tv)</td></tr>
<tr class="memdesc:a57f03901aba6f1e4df97ae91486bf27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node timeout.  <a href="#a57f03901aba6f1e4df97ae91486bf27f">More...</a><br /></td></tr>
<tr class="separator:a57f03901aba6f1e4df97ae91486bf27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214d0f9257a3a73a7fc14968249899a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a214d0f9257a3a73a7fc14968249899a2">dht_node_work</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n)</td></tr>
<tr class="memdesc:a214d0f9257a3a73a7fc14968249899a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service the node.  <a href="#a214d0f9257a3a73a7fc14968249899a2">More...</a><br /></td></tr>
<tr class="separator:a214d0f9257a3a73a7fc14968249899a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898633b69aeae99971cf738b9478ee9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a898633b69aeae99971cf738b9478ee9d">dht_node_cleanup</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n)</td></tr>
<tr class="memdesc:a898633b69aeae99971cf738b9478ee9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup DHT node.  <a href="#a898633b69aeae99971cf738b9478ee9d">More...</a><br /></td></tr>
<tr class="separator:a898633b69aeae99971cf738b9478ee9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929022d8cc9b1f6d1f4358c66daafa50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a929022d8cc9b1f6d1f4358c66daafa50">dht_node_search</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const unsigned char id[20], int search_type, <a class="el" href="node_8h.html#a736b2d62686f9713e08e11b25e8d02cd">search_complete_t</a> callback, void *opaque, <a class="el" href="node_8h.html#a75404d24c510013ce7d61dee6d25323b">dht_search_t</a> *handle)</td></tr>
<tr class="memdesc:a929022d8cc9b1f6d1f4358c66daafa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a search on the DHT.  <a href="#a929022d8cc9b1f6d1f4358c66daafa50">More...</a><br /></td></tr>
<tr class="separator:a929022d8cc9b1f6d1f4358c66daafa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd051965b69cc2c154fa5ef5c519e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a5dd051965b69cc2c154fa5ef5c519e12">dht_node_cancel</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, <a class="el" href="node_8h.html#a75404d24c510013ce7d61dee6d25323b">dht_search_t</a> handle)</td></tr>
<tr class="memdesc:a5dd051965b69cc2c154fa5ef5c519e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending DHT search.  <a href="#a5dd051965b69cc2c154fa5ef5c519e12">More...</a><br /></td></tr>
<tr class="separator:a5dd051965b69cc2c154fa5ef5c519e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3f1ef5a75ac6c8ec38ef8ffa8f8c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a4a3f1ef5a75ac6c8ec38ef8ffa8f8c5f">dht_node_dump_buckets</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n)</td></tr>
<tr class="memdesc:a4a3f1ef5a75ac6c8ec38ef8ffa8f8c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the node's routing table.  <a href="#a4a3f1ef5a75ac6c8ec38ef8ffa8f8c5f">More...</a><br /></td></tr>
<tr class="separator:a4a3f1ef5a75ac6c8ec38ef8ffa8f8c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ed86e3a0efdb4214c1804bf411fe25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#af8ed86e3a0efdb4214c1804bf411fe25">dht_node_announce</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const unsigned char *info_hash, const struct <a class="el" href="structsearch__node.html">search_node</a> *nodes, int implied_port, int port)</td></tr>
<tr class="memdesc:af8ed86e3a0efdb4214c1804bf411fe25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send announce queries for an infohash.  <a href="#af8ed86e3a0efdb4214c1804bf411fe25">More...</a><br /></td></tr>
<tr class="separator:af8ed86e3a0efdb4214c1804bf411fe25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe514f902be17bed2e225a9a502e73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#abfe514f902be17bed2e225a9a502e73f">dht_node_put_immutable</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const struct <a class="el" href="structsearch__node.html">search_node</a> *nodes, const struct <a class="el" href="structbvalue.html">bvalue</a> *val)</td></tr>
<tr class="memdesc:abfe514f902be17bed2e225a9a502e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store immutable data in the DHT.  <a href="#abfe514f902be17bed2e225a9a502e73f">More...</a><br /></td></tr>
<tr class="separator:abfe514f902be17bed2e225a9a502e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51af1e65013c3798fd7a4c187463206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#ae51af1e65013c3798fd7a4c187463206">dht_node_put_mutable</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const struct <a class="el" href="structsearch__node.html">search_node</a> *nodes, const unsigned char k[32], const unsigned char signature[64], const unsigned char *salt, size_t salt_len, int seq, const struct <a class="el" href="structbvalue.html">bvalue</a> *val)</td></tr>
<tr class="memdesc:ae51af1e65013c3798fd7a4c187463206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store mutable data in the DHT.  <a href="#ae51af1e65013c3798fd7a4c187463206">More...</a><br /></td></tr>
<tr class="separator:ae51af1e65013c3798fd7a4c187463206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c352ebfac55f2f684e2beb77cc23ac"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbvalue.html">bvalue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a32c352ebfac55f2f684e2beb77cc23ac">dht_node_save</a> (const struct <a class="el" href="structdht__node.html">dht_node</a> *n)</td></tr>
<tr class="memdesc:a32c352ebfac55f2f684e2beb77cc23ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save node state.  <a href="#a32c352ebfac55f2f684e2beb77cc23ac">More...</a><br /></td></tr>
<tr class="separator:a32c352ebfac55f2f684e2beb77cc23ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288dc93f45af79453a18674f813e5a62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#a288dc93f45af79453a18674f813e5a62">dht_node_restore</a> (const struct <a class="el" href="structbvalue.html">bvalue</a> *dict, struct <a class="el" href="structdht__node.html">dht_node</a> *n)</td></tr>
<tr class="memdesc:a288dc93f45af79453a18674f813e5a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore node state.  <a href="#a288dc93f45af79453a18674f813e5a62">More...</a><br /></td></tr>
<tr class="separator:a288dc93f45af79453a18674f813e5a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4e1534d03094754a451f82d9ff7a1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8h.html#aed4e1534d03094754a451f82d9ff7a1c">dht_node_set_bootstrap_callback</a> (struct <a class="el" href="structdht__node.html">dht_node</a> *n, <a class="el" href="node_8h.html#ac1683aa1d614d82219fa3712dab05857">bootstrap_status_t</a> callback, void *opaque)</td></tr>
<tr class="memdesc:aed4e1534d03094754a451f82d9ff7a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bootstrap status notification callback.  <a href="#aed4e1534d03094754a451f82d9ff7a1c">More...</a><br /></td></tr>
<tr class="separator:aed4e1534d03094754a451f82d9ff7a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>API for running a DHT node. </p>
<p>This file defines low-level methods for a <a class="el" href="structdht__node.html">dht_node</a> object. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac1683aa1d614d82219fa3712dab05857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* bootstrap_status_t) (int ready, void *opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bootstrap status notification callback. </p>
<p>User-defined callback called when the node boostrap status changes. When <em>ready</em> is non-zero, the node is ready to handle new DHT searches. When <em>ready</em> is zero, the node is bootstraping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ready</td><td>Whether the node is ready. </td></tr>
    <tr><td class="paramname">opaque</td><td>User data pointer passed to <a class="el" href="node_8h.html#aed4e1534d03094754a451f82d9ff7a1c">dht_node_set_bootstrap_callback</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75404d24c510013ce7d61dee6d25323b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct search* <a class="el" href="node_8h.html#a75404d24c510013ce7d61dee6d25323b">dht_search_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search handle. </p>
<p>Handle to a pending DHT search. </p>

</div>
</div>
<a class="anchor" id="a73b5e3db1421f18e2106a5dbe1a44207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* node_output_t) (const unsigned char *data, size_t len, const struct sockaddr *dest, socklen_t addrlen, void *opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node output callback. </p>
<p>User-defined callback for sending UDP datagrams to a remote node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data buffer to send. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data buffer to send. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination address </td></tr>
    <tr><td class="paramname">addrlen</td><td>Length of the <em>dest</em> parameter. </td></tr>
    <tr><td class="paramname">opaque</td><td>User data pointer passed to <a class="el" href="node_8h.html#a823c75f4036a068ef420ad4b50b73419">dht_node_init</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a736b2d62686f9713e08e11b25e8d02cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* search_complete_t) (struct <a class="el" href="structdht__node.html">dht_node</a> *n, const struct <a class="el" href="structsearch__node.html">search_node</a> *nodes, void *opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search complete callback. </p>
<p>This callback is called when a DHT search completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The node handling the search. </td></tr>
    <tr><td class="paramname">nodes</td><td>Linked list of nodes found during the search. Sorted by increasing distance. If NULL, the search either returned no nodes or was cancelled. </td></tr>
    <tr><td class="paramname">opaque</td><td>User data pointer passed to <a class="el" href="node_8h.html#a929022d8cc9b1f6d1f4358c66daafa50">dht_node_search</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af8ed86e3a0efdb4214c1804bf411fe25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_announce </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>info_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsearch__node.html">search_node</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>implied_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send announce queries for an infohash. </p>
<p>Sends DHT announce queries for the given infohash. If <em>implied_port</em> is non-zero, them the <em>port</em> parameter will be ignored and the node's UDP port is used instead as the peer port. This function is only meant to be used with a list of nodes obtained as the result of a <code>GET_PEERS</code> search. Only the 8 nodes of the <em>nodes</em> list will be subject to the announce query. See <a class="el" href="peers_8h.html#a505a9824ae73cc494549fb2839276f2c">dht_announce_peer</a> for a higher level interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">info_hash</td><td>the 160-bit infohash. </td></tr>
    <tr><td class="paramname">nodes</td><td>List of nodes sorted by increasing distance to the target infohash, as returned by <a class="el" href="node_8h.html#a929022d8cc9b1f6d1f4358c66daafa50">dht_node_search</a>. </td></tr>
    <tr><td class="paramname">implied_port</td><td>0 to use the <em>port</em> parameter, 1 to use the current node's UDP port number. </td></tr>
    <tr><td class="paramname">port</td><td>Announced peer's port number if <em>implied_port</em> is 0, ignored otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dd051965b69cc2c154fa5ef5c519e12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_cancel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a75404d24c510013ce7d61dee6d25323b">dht_search_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a pending DHT search. </p>
<p>Cancels a currently running search and frees up associated ressources. The search completion callback will be called immediately with a NULL list of nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">handle</td><td>Handle to the search to cancel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a898633b69aeae99971cf738b9478ee9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup DHT node. </p>
<p>Cleans up the <a class="el" href="structdht__node.html">dht_node</a> and frees all ressources used by the node. All the pending searches will be cancelled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a3f1ef5a75ac6c8ec38ef8ffa8f8c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_dump_buckets </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the node's routing table. </p>
<p>Outputs the node's bucket list for debugging purpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a823c75f4036a068ef420ad4b50b73419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dht_node_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a73b5e3db1421f18e2106a5dbe1a44207">node_output_t</a>&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize DHT node. </p>
<p>Initializes a <a class="el" href="structdht__node.html">dht_node</a> structure with the given node ID <em>id</em>. If the <em>id</em> parameter is NULL, the node ID will be generated randomly. To remain platform independent, the library does not handle network operations by itself, therefore the user needs to provide <em>output</em>, a callback that takes care of sending UDP datagrams over the network. A very basic implementation of <em>output</em> could be: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> output(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> <a class="code" href="structbvalue.html#a26e26a59b185458fc77d5a0bbfcd1d73">len</a>,</div><div class="line">                   <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *dest, socklen_t addrlen,</div><div class="line">                   <span class="keywordtype">void</span> *opaque)</div><div class="line">{</div><div class="line">    sendto(*(<span class="keywordtype">int</span> *)opaque, data, len, 0, dest, addrlen);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Empty node structure to initialize. </td></tr>
    <tr><td class="paramname">id</td><td>Node identifier to use. </td></tr>
    <tr><td class="paramname">output</td><td>Datagram output callback. </td></tr>
    <tr><td class="paramname">opaque</td><td>Opaque pointer that will be passed to the output callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on allocation error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d88ecca1430b75b6a0d4e897effb823"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_input </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input a received UDP datagram. </p>
<p>This function must be called upon reception of a UDP datagram for the node. Note that his function may bring the node timeout forward. (see <a class="el" href="node_8h.html#a57f03901aba6f1e4df97ae91486bf27f">dht_node_timeout</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">data</td><td>Data received. </td></tr>
    <tr><td class="paramname">len</td><td>Length of received data. </td></tr>
    <tr><td class="paramname">src</td><td>Sender address. </td></tr>
    <tr><td class="paramname">addrlen</td><td>Length of the <em>src</em> parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cadf472420de8aeace356755669cf65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_ping </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ping remote node. </p>
<p>Sends a ping query to the specified host. Querying a node known by address will help speed-up the bootstrap process: if the remote hosts responds, it will immediately be added to the routing table and will be used in subsequent DHT searches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">dest</td><td>Address of the DHT node to ping. </td></tr>
    <tr><td class="paramname">addrlen</td><td>Length of the <em>dest</em> parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfe514f902be17bed2e225a9a502e73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_put_immutable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsearch__node.html">search_node</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structbvalue.html">bvalue</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store immutable data in the DHT. </p>
<p>Send a "put" query to the specified nodes with the given value <em>val</em> to store as immutable data. Only the 8 first nodes of the <em>nodes</em> list will be subject to the announce query. See <a class="el" href="put_8h.html#ae34d30e7907ec1f88ac24709d3fb2ced">dht_put_immutable</a> for a higher level interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">nodes</td><td>List of nodes sorted by increasing distance to the target hash, as returned by <a class="el" href="node_8h.html#a929022d8cc9b1f6d1f4358c66daafa50">dht_node_search</a>. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be stored on the target nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae51af1e65013c3798fd7a4c187463206"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_put_mutable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsearch__node.html">search_node</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>k</em>[32], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>signature</em>[64], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>salt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>salt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structbvalue.html">bvalue</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store mutable data in the DHT. </p>
<p>Send a "put" query to the specified nodes with the given value <em>val</em> to store as mutable data. Only the 8 first nodes of the <em>nodes</em> list will be subject to the put query. See <a class="el" href="put_8h.html#a6f283e2abb8b6ab4ed80db9b1256991e">dht_put_mutable</a> for a higher level interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">nodes</td><td>List of nodes sorted by increasing distance to the target hash, as returned by <a class="el" href="node_8h.html#a929022d8cc9b1f6d1f4358c66daafa50">dht_node_search</a>. </td></tr>
    <tr><td class="paramname">k</td><td>ed25519 public key used to authenticate the query. </td></tr>
    <tr><td class="paramname">signature</td><td>ed25519 signature of the query. </td></tr>
    <tr><td class="paramname">salt</td><td>Salt data added to compute the target hash. </td></tr>
    <tr><td class="paramname">salt_len</td><td>Length of the salt data (max=64). </td></tr>
    <tr><td class="paramname">seq</td><td>Sequence number. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be stored on the target nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a288dc93f45af79453a18674f813e5a62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dht_node_restore </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbvalue.html">bvalue</a> *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore node state. </p>
<p>Restores the node to a previous state. The result of calling this function after the node has already started with <a class="el" href="node_8h.html#a05d271bbce0682f65e7b1a861a7d85df">dht_node_start</a> is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>The state to restore as a dictionary value. </td></tr>
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 if <em>dict</em> is invalid (invalid version). </dd></dl>

</div>
</div>
<a class="anchor" id="a32c352ebfac55f2f684e2beb77cc23ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbvalue.html">bvalue</a>* dht_node_save </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save node state. </p>
<p>Saves the state of a node into a dictionnary value ready to be serialized to a file. This function saves the node ID an the content of the node's routing table. This allows the node to be stopped and then restarted in a future invocation of the same software without having to go through the bootstrap process again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node's state as a dictionary value. </dd></dl>

</div>
</div>
<a class="anchor" id="a929022d8cc9b1f6d1f4358c66daafa50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dht_node_search </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>id</em>[20], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a736b2d62686f9713e08e11b25e8d02cd">search_complete_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a75404d24c510013ce7d61dee6d25323b">dht_search_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a search on the DHT. </p>
<p>Start a recursive search on the DHT. There are multiple types of search (<code>FIND_NODE</code>, <code>GET_PEERS</code> and <code>GET</code>), each using a different query method (respectively <em>find_node</em>, <em>get_peers</em>, and <em>get</em>), but the search algorithm remains the same in all cases. The returned search handle can be used to cancel a pending search with <a class="el" href="node_8h.html#a5dd051965b69cc2c154fa5ef5c519e12">dht_node_cancel</a>. The search completes when no nodes can be found closer to the target ID, the <a class="el" href="node_8h.html#a736b2d62686f9713e08e11b25e8d02cd">search_complete_t</a> callback will then be called with a list of all the nodes found during the search. This is a low-level interface, consider using functions in <a class="el" href="peers_8h.html">peers.h</a> or <a class="el" href="put_8h.html">put.h</a> instead. The returned search handle becomes invalid after the search completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">search_type</td><td>Type of search. One of the <a class="el" href="node_8h.html#a37cacf032444dc865b3e4290fb445aec">dht_search_type</a> enum values. </td></tr>
    <tr><td class="paramname">id</td><td>The search target. </td></tr>
    <tr><td class="paramname">callback</td><td>Function that will be called when the search completes. </td></tr>
    <tr><td class="paramname">opaque</td><td>Opaque pointer that will be passed to the callback when the search completes. </td></tr>
    <tr><td class="paramname">handle</td><td>Pointer to a variable that will receive the search handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the search sucessfully started, or -1 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aed4e1534d03094754a451f82d9ff7a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_set_bootstrap_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#ac1683aa1d614d82219fa3712dab05857">bootstrap_status_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bootstrap status notification callback. </p>
<p>Register a callback that will be called when the node's bootstrap status changes. It allows the user to be notified when the node is ready to issue DHT searches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">callback</td><td>Bootstrap status callback. </td></tr>
    <tr><td class="paramname">opaque</td><td>Opaque pointer that will be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bootstrap status. </dd></dl>

</div>
</div>
<a class="anchor" id="a05d271bbce0682f65e7b1a861a7d85df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dht_node_start </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start DHT node. </p>
<p>Starts servicing the DHT node. Bootstrap node if the routing table is empty. Changing the node's ID or restoring a previous state must be done before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The node to start. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57f03901aba6f1e4df97ae91486bf27f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get node timeout. </p>
<p>Returns the amount of time after which the node needs to be serviced (by calling <a class="el" href="node_8h.html#a214d0f9257a3a73a7fc14968249899a2">dht_node_work</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
    <tr><td class="paramname">tv</td><td>A pointer to a timeval structure in which the timeout value will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a214d0f9257a3a73a7fc14968249899a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dht_node_work </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdht__node.html">dht_node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Service the node. </p>
<p>The user is required to call this function every so often to perform maintenance work (routing table updates) on the node or make progress on pending searches. It is recommended to call this function every second or use <a class="el" href="node_8h.html#a57f03901aba6f1e4df97ae91486bf27f">dht_node_timeout</a> to figure out when to call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The DHT node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
